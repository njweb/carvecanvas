{
  "name": "Carvecanvas",
  "tagline": "A small library to assist in the creation of dynamic paths for the html canvas object's 2D context.",
  "body": "# Carve Canvas v0.2.2\r\n\r\n## What is it?\r\n\r\n   A small JS library to help make drawing dynamic paths into `<canvas>` elements easier.\r\n\r\n## Examples\r\n\r\n   A simple example\r\n   \r\n   **Note: Within this library 2D vectors are expected as two element arrays, so \\[x, y\\]**\r\n\r\n```javascript\r\nimport carve from 'carve-canvas'\r\nlet canvasCtx = document.querySelector('#my-canvas').getContext('2d');\r\nlet carveObj = carve(canvasCtx);\r\n\r\ncanvasCtx.beginPath();\r\n\r\ncarveObj.sequence((carveCtx) => {\r\n    carveCtx\r\n        .moveTo([10, 10])\r\n        .lineTo([50, 50) \r\n        .lineTo([50, 10])\r\n        .commit(); //This will send our stored instructions into the 2D context object.\r\n    });\r\n    \r\ncanvasCtx.fillStyle = '#4A4';\r\ncanvasCtx.fill();\r\n```\r\n\r\n   Ok, so that's the very basics.\r\n   Now, let's add some transformations that are applied to subsequent input operations.\r\n\r\n```javascript\r\nimport carve from 'carve-canvas'\r\nlet canvasCtx = document.querySelector('#my-canvas').getContext('2d');\r\nlet carveObj = carve(canvasCtx);\r\n\r\ncarveObj.sequence((carveCtx) => {\r\n    // The carve 'context' object has a transform stack we can push offsets to.\r\n    carveCtx.pushTransform([0, 10])\r\n    .moveTo([0, -10])\r\n    .lineTo([-10, 0])\r\n    \r\n    // Transforms combine as we push them to the stack,\r\n    //     so our current global transform point is [0, 50].\r\n    .pushTransform([0, 40]) \r\n    .lineTo([-10, 0])\r\n    .lineTo([0, 10])\r\n    .lineTo([10, 0])\r\n    \r\n    // And now we're back to [0, 10].\r\n    .popTransform()\r\n    .lineTo([10, 0])\r\n    .commit((canvasCtx, trigger) => { //we can pass a function to .commit\r\n            // The predicate we pass to .commit gets the original CanvasRenderingContext2D\r\n            //   object we passed in when we created carveCtx.\r\n            canvasCtx.beginPath();\r\n    \r\n            // By calling this trigger function, all our stored instructions \r\n            //   get dumped into the canvas context\r\n            trigger();\r\n    \r\n            // We can do our canvas context drawing \r\n            //   configuration/execution in this predicate function\r\n            canvasCtx.fillStyle = '#0C0'; \r\n            canvasCtx.fill();\r\n        });\r\n    });\r\n```\r\n\r\n   And now, we can break our paths up into sequences that can be chained together\r\n   \r\n```javascript\r\nimport carve from 'carve-canvas'\r\nlet canvasCtx = document.querySelector('#my-canvas').getContext('2d');\r\nlet carveObj = carve(canvasCtx);\r\n\r\ncarveObj.sequence((carveCtx) =>\r\n    carveCtx.pushTransform([-40, 0])\r\n        .moveTo([-10, 0])\r\n        // The .sequence method takes a handler function\r\n        .sequence((seqCtx) => {\r\n            // The first argument passed into the\r\n            //   sequence handler funtion is our carveCtx object\r\n            //   unless that behavior has been overridden\r\n\r\n            seqCtx.pushTransform([40, 40])\r\n                .lineTo([-20, 10])\r\n                .lineTo([20, 10]);\r\n\r\n            seqCtx.sequence((seqCtx) => {\r\n                seqCtx.pushTransform([40, -40])\r\n                    .lineTo([10, 0])\r\n                    .lineTo([-10, 0]);\r\n            });\r\n\r\n            // When we return from a sequence, our transform is\r\n            //   right where we left it.\r\n            seqCtx.lineTo([0, -10]);\r\n        });\r\n    });\r\n```\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}